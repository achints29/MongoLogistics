# Logistics Project

## Student: Achint Shrivastava 
### Version: 2.0

## Installation Instructions
This implementation is written in Java.  
It builds upon the learnings during the course and uses a DAL layer to interact with MongoDB Connections. Below is the brief description of the project structure and classes.

## Project Structure

```
├── README.md
├── pom.xml
└── src
    └── main
        ├── java
        │   └── org
        │       └── example
        │           └── mongodb
        │               ├── APIRoutes.java
        │               ├── CargoDAL.java
        │               ├── CityDAL.java
        │               ├── Constants.java
        │               ├── PlaneDAL.java
        │               ├── PlaneLandingEventListener.java
        │               ├── WebService.java
        │               └── util
        │                   └── DistanceUtil.java
        └── resources
            └── logback.xml

```


## Installation instructions
1. Clone this repository using `git clone`
        
## Running the Application
Ensure that you have Java and Maven installed.  In the project root directory (same location as `pom.xml`), execute the below commands to run the application.  The application listens on `localhost:5000`
1. `mvn comile`
2. `mvn package`
3. `java -jar webService.jar <mongouri>`  
    The webService takes a parameter specifying the Mongo URI for the application to connect to.  
    ### Note: the Mongo URI should point to a _Replica Set_, for the Change Stream to be processed.  
      
      Example invocation:  

    `java -jar webService.jar mongodb+srv://username:password@test.host.mongodb.net/logistics`

## Importing initial data and creating required indexes

1. Initial data is imported as provided in Task 1 (no change in below scripts from the given; inserted here for completeness)
```
mongoimport logistics --collection worldcities --headerline -d logistics -c worldcities --type=csv --verbose --file worldcities.csv

minsize = {$match:{population:{$gt:500000}}}
sortbysize = { $sort : { population: -1 }}
onepercountry = { $group : { _id: "$country", city : { $first : "$$ROOT" }}}
format = { $project : { _id: "$city.city_ascii", position:["$city.lng","$city.lat"] , country: "$city.country" }}
newcollection = { $out : "cities" }
db.worldcities.aggregate([minsize,sortbysize,onepercountry,format,newcollection])


firstN = { $sample: { size: 16} }
addidone = { $group: { _id: null, planes : { $push : { currentLocation :"$position" }}}}
unwind = { $unwind : {path: "$planes", includeArrayIndex: "id" }}
format = {$project : { _id : {$concat : ["CARGO",{$toString:"$id"}]},
currentLocation: "$planes.currentLocation", heading:{$literal:0}, route: []}}
asplanes = { $out: "planes"}
db.cities.aggregate([firstN,addidone,unwind,format,asplanes])
```
2. Geo Sphere Index to be created on the `position` field of the `cities` collection as given below.    
The 2dsphere index is _required_ for using the $near operator in the `/cities/<name>/neighbors` API, and will not function without this index.


```
db.cities.createIndex( { position : "2dsphere" } )
```
Note: It is possible to create this index using Mongo driverinside the application code.  However, that is a poor practice, since the application user should not have rights to create / delete indexes.

## Scripts for Task 3(b)
### Note: The minimum MongoDB version supported is 4.4

Below scripts assume that the worldcities.csv has been imported into the collection as given in Task 1

1. Creating 2102 cities  
        (a) Same city names exist in different countries. To address this, the _id is generated by concatenating the city name with ios2.
        (b) Some cities have a `/` in their name.  The `/` is replaced with `_` using the `$replaceAll` aggregation operator which is introduced in version 4.4.    

    The script to generate cities is given below, which creates 2102 documents in the cities collection.
  
  ```
minsize = {$match:{population:{$gt:1000}}}
sortbysize = { $sort : { population: -1 }}
groupByCountry = { $group : { _id: "$country", allCities : { $addToSet : "$$ROOT" }}}
slicedTo15orLess = { $project : { slicedTo15orLess: {$slice:["$allCities",0,15]} }}
unwind = {$unwind:{path:"$slicedTo15orLess",includeArrayIndex:'false'}}
format = { $project : { _id: { $replaceAll: { input: { $concat: [ "$slicedTo15orLess.city_ascii", "_", "$slicedTo15orLess.iso2" ] }, find: '/', replacement: '_' } }, position:["$slicedTo15orLess.lng","$slicedTo15orLess.lat"] , country: "$slicedTo15orLess.country" }}
newcollection = { $out : "cities" }
db.worldcities.aggregate([minsize,sortbysize,groupByCountry,slicedTo15orLess,unwind,format,newcollection])
```  
2. Generating 200 planes

```
firstN = { $sample: { size: 200} }
addidone = { $group: { _id: null, planes : { $push : { currentLocation :"$position" }}}}
unwind = { $unwind : {path: "$planes", includeArrayIndex: "id" }}
format = {$project : { _id : {$concat : ["CARGO",{$toString:"$id"}]},
currentLocation: "$planes.currentLocation", heading:{$literal:0}, route: []}}
asplanes = { $out: "planes"}
db.cities.aggregate([firstN,addidone,unwind,format,asplanes])
```
